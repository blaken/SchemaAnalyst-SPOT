#####################################################################
# effect-size.R
#
# Loads in a set of previous results generated by experiment.R
# and compares the optimal results found with parameter tuning
# with those from running SchemaAnalyst with default parameters.
#
# ----- Usage: -------------------------------------------------
# Note: It is expected that this code will be run from the 
# project directory root for SchemaAnalyst; otherwise, there 
# will be classpath issues. From here, the functions can
# be loaded by running
# source("spot/effect-size.R")
#
# Then, the effect size metrics can be calculated for a set of
# .RDate results files with
# calculateEffectSize("path/to/resultsFiles/")
# --------------------------------------------------------------
#
# Author: Nathaniel Blake
#####################################################################

require(compute.es) # provides the effect size calculation mes()

calculateEffectSize <- function(resultsDirectory) {
	# initialize two empty sets of mutation scores
	optMutScores <- vector() # scores using optimized parameters
	defMutScores <- vector() # scores using default parameters

	for (fileName in list.files(path=resultsDirectory)) {
		# only load in .RData files
		if (!grepl(".RData", fileName))
			next # that is, continue to the next fileName

		# load the result set from this file
		print(paste0("Loading ", fileName, "..."))
		load(paste0(resultsDirectory, fileName))

		# abbreviate the current result reference
		curRes <- res$alg.currentResult

		# Rename the results data columns.
		names(curRes)[7] <- "NegateRows"
		names(curRes)[8] <- "SatisfyRows"
		names(curRes)[9] <- "RandomProfile"
		names(curRes)[10] <- "RandomSeed"
		names(curRes)[11] <- "MutationScore"
		names(curRes)[12] <- "GenerationTime"

		# Re-invert the mutation score; we no longer need to minimize it as does SPOT,
		# so seeing the actual score will be more useful in graphics.
		curRes["MutationScore"] <- 1 - curRes["MutationScore"]

		# Get the optimal result (highest mutation score, lowest generation time)
		# (Note that MutationScore is sorted in descending order while GenerationTime
		# is sorted in ascending order.
		attach(curRes) # temporarily attach the result set for ordering
		optMutationScore <- head(curRes[order(-MutationScore, GenerationTime),]["MutationScore"], n=1)
		detach(curRes)

		# add this optimal result to the set of optimal mutation scores
		optMutScores <- rbind(optMutScores, optMutationScore)

		# gather experiment details from file name
		schemaName <- unlist(strsplit(fileName, "-"))[1] # extract schema from file name
		generatorName <- unlist(strsplit(fileName, "-"))[2] #extract generator from file name

		# generate the set of INSERT statements using the current parameters
		print(paste0("Running SchemaAnalyst with default parameters for schema ",
			  schemaName," using generator ",generatorName,"."))
		genCallString <- paste("java -Xmx3G -cp build/:lib/*",
								" org.schemaanalyst.mutation.analysis.util.GenerateResultsFromGenerator",
								" parsedcasestudy.", schemaName, 
								" --datagenerator=", generatorName, " --writeReport",
								" --reportLocation=spot/generationCosts.dat", sep = "")
		system(genCallString, intern=FALSE)

		# use Original mutation analysis on the resulting set of statements
		analysisCallString <- paste("java -Xmx3G -cp build/:lib/*",
									" org.schemaanalyst.mutation.analysis.technique.Original",
									" parsedcasestudy.", schemaName, " 1", 
									" --outputfolder=spot/analyses/", sep = "")
		system(analysisCallString, intern=FALSE);

		# load in the result from this (non-optimized) run
		scores <- read.csv(paste("spot/analyses/parsedcasestudy.", schemaName, ".dat", sep=""))
		mutationNumerator <- tail(scores$scorenumerator, n=1)
		mutationDenominator <- tail(scores$scoredenominator, n=1)
		defMutationScore <- mutationNumerator / mutationDenominator

		# add this score to the set of defaults-generated mutation scores
		defMutScores <- rbind(defMutScores, defMutationScore)
	}

	# convert from list to basic vector for use with mes()
	optMutScores <- unlist(optMutScores)
	defMutScores <- unlist(defMutScores)

	# calculate and print effect size-related values
	print(mes(mean(optMutScores), mean(defMutScores), 
		sd(optMutScores), sd(defMutScores), 
		length(optMutScores), length(defMutScores)))
}
